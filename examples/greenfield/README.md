## AWS S3 Provisioner - Dynamically Create New Bucket OBC Example
This example will walk through the basic steps needed to dynamically provision
a new AWS S3 Bucket and grant access and use. The bucket requester will get a new AWS IAM user, policy and access id and keys 
obtained from the normal ConfigMap and Secrets generated by the provisioning library.
It utilizes a Kubernetes [CustomResourceDefinition](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/)
that defines the ObjectBucket (OB) and ObjectBucketClaim (OBC) resources for your cluster. This design
pattern mimics the Kubernetes PersistentVolume and PersistentVolumeClaim model.

### Table Of Contents
1. [Assumptions](#assumptions)
1. [Deploy or Run AWS S3 Provisioner on Cluster](#deploy-or-run-aws-s3-provisioner-on-cluster)
1. [Administrator Creates Secret](#administrator-creates-secret)
1. [Administrator Creates StorageClass](#administrator-creates-storageclass)
1. [User Creates ObjectBucketClaim](#user-creates-objectbucketclaim)
1. [Results and Recap](#results-and-recap)
1. [User Creates Pod](#user-creates-pod)

### Assumptions
This example assumes some familiarity with Kubernetes and AWS and that a Kubernetes
cluster is available to use. This example also breaks the work flow operations into 
two basic use cases; Administrator and Developer/Application Owner.

### Deploy or Run AWS S3 Provisioner on Cluster
**NOTE:** This will be updated with pod/deployment spec when ready, for now
we are documenting the current developer flow.
 
1. Clone this repo and build the binary or copy the binary to the cluster where it needs to run.
```
  # go build -a -o ./bin/awss3provisioner  ./cmd/...
  # scp /bin/awss3provisioner <user>@<kube-cluster-host>:~
```
2. Create the ObjectBucket and ObjectBucketClaim [CustomResourceDefinitions](https://github.com/yard-turkey/lib-bucket-provisioner/blob/master/deploy/customResourceDefinitions.yaml).

3. Run the provisioner (after the CRD's are created) passing in *master* and *kubeconfig* parameters.
```
 # ./awss3provisioner -master https://localhost:6443 -kubeconfig /var/run/kubernetes/admin.kubeconfig -alsologtostderr -v=2

I0403 10:30:40.881043   16396 aws-s3-provisioner.go:458] AWS S3 Provisioner - main
I0403 10:30:40.881264   16396 aws-s3-provisioner.go:459] flags: kubeconfig="/var/run/kubernetes/admin.kubeconfig"; masterURL="https://localhost:6443"
I0403 10:30:40.883873   16396 manager.go:75] objectbucket.io "level"=0 "msg"="new provisioner"  "name"="aws-s3.io/bucket"
I0403 10:30:40.884624   16396 manager.go:87] objectbucket.io "level"=2 "msg"="generating controller manager"  
I0403 10:30:40.923627   16396 manager.go:94] objectbucket.io "level"=2 "msg"="adding schemes to manager"  
I0403 10:30:40.923742   16396 reconiler.go:54] objectbucket.io/reconciler/aws-s3.io/bucket "level"=0 "msg"="constructing new reconciler"  "provisioner"="aws-s3.io/bucket"
I0403 10:30:40.923766   16396 reconiler.go:59] objectbucket.io/reconciler/aws-s3.io/bucket "level"=2 "msg"="retry loop setting"  "RetryBaseInterval"=10000000000
I0403 10:30:40.923779   16396 reconiler.go:63] objectbucket.io/reconciler/aws-s3.io/bucket "level"=2 "msg"="retry loop setting"  "RetryTimeout"=360000000000
I0403 10:30:40.923791   16396 manager.go:132] objectbucket.io "level"=0 "msg"="building controller manager"  
I0403 10:30:40.924741   16396 aws-s3-provisioner.go:472] main: running aws-s3.io/bucket provisioner...
I0403 10:30:40.924763   16396 manager.go:150] objectbucket.io "level"=0 "msg"="Starting manager"  "provisioner"="aws-s3.io/bucket"
```

### Administrator Creates Secret
This secret will contain the elevated/admin privileges needed by the provisioner
to properly access and create S3 Buckets and IAM users and policies. The AWS Access ID
and AWS Secret Key will be needed for this.

1. Create the Kubernetes Secret for the Provisioner's Owner Access.
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: s3-bucket-owner [1]
  namespace: s3-provisioner [2]
type: Opaque
data:
  AWS_ACCESS_KEY_ID: *base64 encoded value* [3]
  AWS_SECRET_ACCESS_KEY: *base64 encoded value* [4]

```
1. Name of the secret, this will be referenced in StorageClass.
1. Namespace where the Secret will exist.
1. Your AWS_ACCESS_KEY_ID base64 encoded.
1. Your AWS_SECRET_ACCESS_KEY base64 encoded.

```
 # kubectl create -f creds.yaml
secret/s3-bucket-owner created
```

### Administrator Creates StorageClass
The StorageClass is used to indicate what type of provisioner is used
and holds other properties and values that are needed by the provisioner, including
the Owner Secret, Namespace, AWS Region it will serve and if the provisioner will
dynamically provision a bucket (Greenfield) or it will simply grant access to
an existing bucket (Brownfield).


1. Create the Kubernetes StorageClass for the Provisioner.
```yaml
kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: s3-buckets [1]
provisioner: aws-s3.io/bucket [2]
parameters:
  region: us-west-1 [3]
  secretName: s3-bucket-owner [4]
  secretNamespace: s3-provisioner [5]
reclaimPolicy: Delete [7]
volumeBindingMode: Immediate

```
1. Name of the StorageClass, this will be referenced in the User ObjectBucketClaim.
1. Provisioner name
1. AWS Region that the StorageClass will serve
1. Name of the created owner Secret created in the previous step
1. Namespace where the Secret will exist.
1. reclaimPolicy (Delete or Retain) indicates if the bucket can be deleted when the OBC is deleted.

**NOTE:** There is no *bucketName* parameter in the StorageClass - this indicates that the bucket
will be dynamically provisioned brand-new.

```
 # kubectl create -f storageclass-greenfield.yaml
storageclass.storage.k8s.io/s3-buckets created
```

### User Creates ObjectBucketClaim
An ObjectBucketClaim follows the same concept as a PVC, in that
it is a request for Object Storage, the user doesn't need to
concern him/herself with the underlying storage, just that
they need access to it. The user will work with the cluster/storage
administrator to get the proper StorageClass needed and will
then request access via the OBC.


1. Create the ObjectBucketClaim.
```yaml
apiVersion: objectbucket.io/v1alpha1
kind: ObjectBucketClaim
metadata:
  name: myobc [1]
  namespace: s3-provisioner [2]
spec:
  generateBucketName: mybucket [3]
  bucketName: my-awesome-bucket [4]
  storageClassName: s3-buckets [5]
  SSL: true
  versioned: true

```
1. Name of the OBC.
1. Namespace where the OBC will exist.
1. (optional) generateBucketName is ignored if bucketName exists, and will generate a bucketname with the value listed as the prefix i.e. mybucket-XXXXX-XXXXX.
1. (optional) bucketName can be used to specify the exact name of your new bucket, if the same bucket already exists though, an error will be generated.
1. StorageClass name

**NOTE:** In this example, if we exclude both generateBucketName and bucketName an auto-generated bucket name
will be created as the default behavior since the StorageClass has no *bucketName* field, which indicates this is Greenfield and dynamically
provisioned buckets will happen. If both are included, then bucketName will override the generateBucketName.

```
 # kubectl create -f obc-brownfield.yaml
objectbucketclaim.objectbucket.io/myobc created
```

### Results and Recap
Let's pause for a moment and digest what just happened.
At this point, we now have an ObjectBucket that was created
based on our ObjectBucketClaim. OB and OBC are always a 1:1
relationship. In that OB, it will reference the bucket and user that
were created, storageclass and endpoint information for the bucket.

We also created a ConfigMap and a Secret which can be used
to access the bucket from a Pod.

And of course, we have a *NEW* AWS S3 Bucket which you should be able
to see via the AWS Console.


*ObjectBucket*
```yaml
 # kubectl get ob obc-s3-provisioner-my-awesome-bucket -o yaml
apiVersion: objectbucket.io/v1alpha1
kind: ObjectBucket
metadata:
  creationTimestamp: "2019-04-03T15:42:22Z"
  generation: 1
  name: obc-s3-provisioner-my-awesome-bucket
  resourceVersion: "15057"
  selfLink: /apis/objectbucket.io/v1alpha1/objectbuckets/obc-s3-provisioner-my-awesome-bucket
  uid: 0bfe8e84-576d-4c4e-984b-f73c4460f736
spec:
  Connection:
    additionalState:
      ARN: arn:aws:iam::<accountid>:policy/my-awesome-bucket-vSgD5 [1]
      UserName: my-awesome-bucket-vSgD5 [2]
    endpoint:
      additionalConfig: null
      bucketHost: s3-us-west-1.amazonaws.com
      bucketName: my-awesome-bucket [3]
      bucketPort: 443
      region: us-west-1
      ssl: true
      subRegion: ""
  claimRef: null
  reclaimPolicy: null
  storageClassName: s3-buckets [4]
```
1. The AWS Policy created for this user and bucket.
1. The new user generated by the Provisioner to access this existing bucket.
1. The bucket name.
1. The reference to the StorageClass used.


*ConfigMap*
```yaml
 # kubectl get cm myobc -n s3-provisioner -o yaml
apiVersion: v1
data:
  BUCKET_HOST: s3-us-west-1.amazonaws.com [1]
  BUCKET_NAME: my-awesome-bucket [2]
  BUCKET_PORT: "443"
  BUCKET_REGION: us-west-1
  BUCKET_SSL: "true"
  BUCKET_SUBREGION: ""
  BUCKET_URL: s3-us-west-1.amazonaws.com:443/us-west-1/my-awesome-bucket [3]
kind: ConfigMap
metadata:
  creationTimestamp: "2019-04-01T19:11:38Z"
  finalizers:
  - objectbucket.io/finalizer
  name: my-awesome-bucket
  namespace: s3-provisioner
  resourceVersion: "892"
  selfLink: /api/v1/namespaces/s3-provisioner/configmaps/my-awesome-bucket
  uid: 2edcc58a-aff8-4a29-814a-ffbb6439a9cd
```
1. The AWS S3 host.
1. The name of the new bucket we are gaining access to.
1. The bucket endpoint.

*Secret*
```yaml
 # kubectl get secret my-awesome-bucket -n s3-provisioner -o yaml
apiVersion: v1
data:
  AWS_ACCESS_KEY_ID: *the_new_access_id* [1]
  AWS_SECRET_ACCESS_KEY: *the_new_access_key_value* [2]
kind: Secret
metadata:
  creationTimestamp: "2019-04-03T15:42:22Z"
  finalizers:
  - objectbucket.io/finalizer
  name: my-awesome-bucket
  namespace: s3-provisioner
  resourceVersion: "15058"
  selfLink: /api/v1/namespaces/s3-provisioner/secrets/screeley-provb-5
  uid: 225c71a5-9d75-4ccc-b41f-bfe91b272a13
type: Opaque
```
1. The new generated AWS Access Key ID.
1. The new generated AWS Secret Access Key.

What happened in AWS? The first thing we do on any OBC request is
create a new IAM user and generate Access ID and Secret Keys.
This allows us to also better control ACLs. We also create a policy
in IAM which we then attach to the user and bucket.
When the OBC is deleted, the generated user and policy is also deleted.

We also created a new bucket, called *my-awesome-bucket*. If the retainPolicy
on the StorageClass that created this bucket is *Delete*, then when the OBC
is deleted by the user, the bucket and all of it's data will also be deleted.


### User Creates Pod
Now we have our bucket and connection/access information, a pod
can be used to access the bucket. This can be done in several different
ways, but the key here is that the provisioner has provided the proper
endpoints and keys to access the bucket. The user then simply references
the keys.

1. Create a Sample Pod to Access the Bucket.
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: photo1
  labels:
    name: photo1
spec:
  containers:
  - env:
    - name: BUCKET_NAME
      value: "my-awesome-bucket" [1]
    - name: BUCKET_ID [2]
      valueFrom:
            secretKeyRef:
              name: my-awesome-bucket [4]
              key: AWS_ACCESS_KEY_ID
    - name: BUCKET_PWORD [3]
      valueFrom:
            secretKeyRef:
              name: my-awesome-bucket [4]
              key: AWS_SECRET_ACCESS_KEY
    - name: OBJECT_STORAGE_S3_TYPE
      value: "aws"
    - name: OBJECT_STORAGE_CLUSTER_PORT
      value: "443"
    - name: OBJECT_STORAGE_REGION
      value: "us-west-1"
    image: docker.io/zherman/demo:latest
    imagePullPolicy: Always
    name: photo1
    ports:
    - containerPort: 3000
      protocol: TCP
```
1. Name of the bucket we created
1. AWS S3 UserName (access_key) from our generated Secret
1. AWS S3 Password (access_secret_key) from our generated Secret
1. The auto-generated name of the Secret

**NOTE:** This is just one example of a Pod that can utilize the bucket information,
there are several ways that these pod applications can be developed and therefore
the method of getting the actual values needed from the Secrets and ConfigMaps
will vary greatly, but the idea remains the same, that the pod consumes the generated
ConfigMap and Secrets from the provisioner.

